Problem up03-1: mz03-1 (дореш)
Напишите функцию process, которая принимает три параметра:

неизменяемый вектор 64-битных беззнаковых целых чисел;
вектор 64-битных беззнаковых целых чисел;
целый положительный параметр: шаг по первому вектору.
Функция проходит элементы первого вектора целых чисел с заданным шагом и прибавляет их в последовательные элементы второго вектора, считая от конца вектора с шагом 1. Размер второго вектора не изменяется, если размер второго вектора недостаточен, лишние элементы игнорируются.

Для работы с векторами использовать только итераторы или range-based for loop.

Например, если в качестве первого параметра передан вектор { 1, 2, 3, 4 }, в качестве второго параметра - вектор { 1, 2, 3 }, и третий параметр равен 2, то после выполнения функции process второй вектор должен быть равен { 1, 5, 4 }.


Problem mz03-2: mz03-2
Напишите функцию process, которая принимает два параметра:

вектор 64-битных знаковых целых чисел;
64-битное знаковое число (порог);
Функция должна добавить в конец вектора в обратном порядке те элементы вектора, значение которых не менее чем пороговое.

Для работы с векторами использовать только итераторы или range-based for loop. Временные векторы или другие контейнеры использовать запрещено.

Например, если на вход передан вектор { 1, 4, 3, 2 } и пороговое значение 3 после выполнения функции вектор должен быть равен { 1, 4, 3, 2, 3, 4 }.



Problem up03-3: mz03-3 (дореш)
Написать функцию process, принимающую два параметра:

неизменяемый вектор целых чисел v1;
вектор целых чисел v2.
Функция должна удалить из вектора v2 элементы с номерами, заданными в векторе v1. Элементы вектора нумеруются от 0. Номера элементов вектора v2 отражают позиции элементов на момент начала работы программы. Если номер повторяется в векторе v1 более одного раза, все вхождения, кроме первого, игнорируются. Если число в векторе v1 не является допустимым номером элемента в векторе v2, оно игнорируется.

Для доступа к элементам векторов использовать только итераторы.

При необходимости допускается создавать локальную копию вектора v1. Из стандартных алгоритмов допускается использовать std::sort, std::unique, std::swap.


Problem up03-4: mz03-4 (дореш)
Программе на стандартном потоке ввода подаётся последовательность вещественных чисел — результат серии экспериментов. Последовательность содержит не менее 10 чисел. Вычислите и выведите на стандартный поток вывода среднее арифметическое для нормализованной выборки. Вещественные числа должны быть напечатаны с 10 десятичными знаками после точки.

Нормализованная выборка — это выборка, у которой отброшены первые и последние 10% измерений (при вычислении 10% дробная часть отбрасывается), затем у оставшейся выборки отбрасываются 10% минимальных и максимальных значений (вычисление 10% ведется от оставшейся после первого отбрасывания части выборки, дробная часть при этом отбрасывается). Итого, в вычислениях участвует 64% от исходной выборки.

Для вычисления среднего арифметического используйте алгоритм for_each. Не используйте глобальные переменные. Не используйте анонимные (lambda) функции. При нарушении ограничений решения будут дисквалифицированы.

Используйте минимальное число копирований элементов вектора.

Обратите внимание, что алгоритм for_each возвращает в качестве результата класс-функтор, переданный ему третьим параметром. Это можно использовать для накопления результата вычисления в классе-функторе.



Problem up03-5: Öбнулись
На стандартном потоке ввода вводится "рваная" матрица целых 32-битных неотрицательных чисел, то есть матрица, у которой разные строки могут иметь различное число столбцов. Матрица задает рельеф карты некоторой страны К...я. Ввод матрицы завершается пустой строкой. Далее до конца файла задаются разрушительные силы поправок, представляющие собой 32-битные целые положительные числа.

В страну вносятся поправки различной разрушительной силы. Каждая поправка накрывает квадрат размером 3x3, причем в центре квадрата разрушительная сила наибольшая и равная разрушительной силе поправки, в четырех прилегающих к центру квадратах разрушительная сила в два раза меньше (деление нацело), а в четырех оставшихся клетках еще в два раза меньше (деление нацело). Разрушительная сила в клетке означает, что высота рельефа в этой клетке уменьшается на величину разрушительной силы, но высота рельефа не может быть меньше 0, то есть если высота рельефа в клетке стала равной 0, она остается далее такой.

Процесс внесения поправок работает следующим образом: на карте выбирается самая высокая точка, а если таковых несколько берется точка с лексикографически минимальной координатой (строка,столбец). В эту точку вносится самая мощная поправка из имеющихся, затем рельеф обновляется и процесс продолжается с оставшимися поправками. Одну поправку можно внести только один раз.

На стандартный поток вывода выведите рельеф после применения всех поправок.

В примере ниже есть две поправки: разрушительной силы 2, то есть с такой матрицей:

0 1 0
1 2 1
0 1 0
и разрушительной силы 1, то есть с матрицей

0 0 0
0 1 0
0 0 0
Первая поправка вносится в точку (0, 1), где рельеф равен 3, после чего вторая поправка вносится в точку (2, 0).

Полное тестирование будет проводиться после занятия!

Examples
Input
2 3 1
1 1
2

2 1
Output
1 1 0
1 0
1


